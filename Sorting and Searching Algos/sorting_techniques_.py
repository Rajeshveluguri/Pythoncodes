# -*- coding: utf-8 -*-
"""Sorting Techniques .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O6jnSBGzLRD1Sp5jiEzo55d6TD7dn0Ox

Bubble Sort Technique

Bubble Sort is an algorithm that sorts an array from the lowest value to the highest value.
Go through the array, one value at a time.
For each value, compare the value with the next value.
If the value is higher than the next one, swap the values so that the highest value comes last.
Go through the array as many times as there are values in the array.
"""

array = [10, 1, 4 , 3, 12, 19, 25, 5, 37]
n = len(array)
for i in range (n-1):
    swapped = False
    for j in range (n-i-1):
      if array[j] > array[j+1]:
        array[j], array[j+1] = array[j+1], array[j]
        swapped = True
      if not swapped:
        break
print ("Sorted Array ", array)

"""Selection Sort Technique

The Selection Sort algorithm finds the lowest value in an array and moves it to the front of the array.
"""

array = [10, 1, 4 , 3, 12, 19, 25, 5, 37, -1]
n = len(array)
for i in range(n-1):
    min_index = i
    for j in range(i+1, n):
        if array[j] < array[min_index]:
            min_index = j
    min_value = array.pop(min_index)
    array.insert(i, min_value)

print("Sorted array:", array)

"""Insertion Sort Technique

The Insertion Sort algorithm uses one part of the array to hold the sorted values, and the other part of the array to hold values that are not sorted yet.

Picks first value and places it in right place and continues with next number
"""

my_array = [64, 34, 25, 12, 22, 11, 90, 5, -14]

n = len(my_array)
for i in range(1,n):
    insert_index = i
    current_value = my_array.pop(i)
    for j in range(i-1, -1, -1):
        if my_array[j] > current_value:
            insert_index = j
    my_array.insert(insert_index, current_value)

print("Sorted array:", my_array)

"""Quick Sort Techinique

The Quicksort algorithm takes an array of values, chooses one of the values as the 'pivot' element, and moves the other values so that lower values are on the left of the pivot element, and higher values are on the right of it.
"""

def partition(array, low, high):
    pivot = array[high]
    i = low - 1

    for j in range(low, high):
        if array[j] <= pivot:
            i += 1
            array[i], array[j] = array[j], array[i]

    array[i+1], array[high] = array[high], array[i+1]
    return i+1

def quicksort(array, low=0, high=None):
    if high is None:
        high = len(array) - 1

    if low < high:
        pivot_index = partition(array, low, high)
        quicksort(array, low, pivot_index-1)
        quicksort(array, pivot_index+1, high)

my_array = [64, 34, 25, 12, 22, 11, 90, 5]
quicksort(my_array)
print("Sorted array:", my_array)

"""Radix Sort Technique

The Radix Sort algorithm sorts an array by individual digits, starting with the least significant digit (the rightmost one).
"""

myArray = [170, 45, 75, 90, 802, 24, 2, 66, -14]
print("Original array:", myArray)
radixArray = [[], [], [], [], [], [], [], [], [], []]
maxVal = max(myArray)
exp = 1

while maxVal // exp > 0:

    while len(myArray) > 0:
        val = myArray.pop()
        radixIndex = (val // exp) % 10
        radixArray[radixIndex].append(val)

    for bucket in radixArray:
        while len(bucket) > 0:
            val = bucket.pop()
            myArray.append(val)

    exp *= 10

print("Sorted array:", myArray)

"""Merge Sort Technique

The Merge Sort algorithm is a divide-and-conquer algorithm that sorts an array by first breaking it down into smaller arrays, and then building the array back together the correct way so that it is sorted.
"""

def mergeSort(arr):
    if len(arr) == 1:
        return arr

    mid = len(arr) // 2
    leftHalf = arr[:mid]
    rightHalf = arr[mid:]

    sortedLeft = mergeSort(leftHalf)
    sortedRight = mergeSort(rightHalf)

    return merge(sortedLeft, sortedRight)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])

    return result

unsortedArr = [3, 7, 6, -10, 15, 23.5, 55, -13]

sortedArr = mergeSort(unsortedArr)
print("Sorted array:", sortedArr)

ar = [1]
len(ar)